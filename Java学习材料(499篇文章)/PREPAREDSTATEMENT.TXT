作者：罗亭
email: tingluo@263.net
日期：7/30/2001 11:59:54 AM
From: www.theserverside.com -->SMTH
翻译: SuperMMX 

     为什么 PreparedStatement 很重要, 以及怎样"正确"使用他们. 

数据库有一个艰苦的工作. 它们不断地从许多客户端读取 SQL 查询, 对数据进行尽 
可能高效的 查询. 处理语句可能成为一个代价较高的操作, 但是现在数据库都是很 
好的设计, 这样这个困难 被减到最小. 但是这些优化需要应用程序开发者的协助, 
这篇文章给你展示一下怎样正确使用 PreparedStatement 来漂亮地帮助数据库执行 
这些优化. 

一个数据库怎样执行一条语句? 

显然, 不要希望这里有许多细节; 我们只看一下对这篇文章比较重要的部分. 当一个 
数据库接收 到一条语句的时候, 数据库引擎首先解析这条语句, 查看语法错误. 一 
旦语句解析了, 数据库 需要找出最有效的方法来执行这条语句. 这个计算起来代价 
很大. 数据库检查什么索引(如果有 的话)能有所帮助, 或者它是否能全部读出一张 
表中所有的记录. 数据库根据这些关于数据库所 存数据的统计数字来找出最好的 
办法. 一旦制订出查询方案, 就可以由数据库引擎来执行. 

需要 CPU 来产生访问方案. 理想的情况, 如果我们把相同的语句给数据库发送两 
次, 我们期望 数据库重用第一条记录的访问方案. 这会比第二次重新产生方案要使 
用较少的 CPU. 

语句缓冲 

数据库可以进行调节来做语句缓冲. 通常包含一些类型的语句缓冲. 缓冲使用语句 
本身作为关键 字, 访问方案和相应的语句存储在缓冲区中. 这样就允许数据库引擎 
对以前执行过的语句所使用 的访问方案进行重用. 举个例子来说, 如果我们向数据 
库发送这样一条语句 "select a, b from t where c = 2", 计算好的访问方案就放入缓冲 
区了. 如果我们以后再使用同样的语 句, 数据库就能重用以前的访问方案, 这样就 
能节省 CPU. 

但是要注意, 整条语句是一个关键字. 例如, 如果我们后来发送的语句是 "select a,b 
from t where c = 3", 那么就不会找出以前的访问方案. 因为 "c=3" 和 "c=2" 是不一 
样的. 所以, 例如: 

     For(int I = 0; I < 1000; ++I) 
{ 
PreparedStatement ps = conn.prepareStatement("select a,b from t 
where c = " + I); 
ResultSet rs = Ps.executeQuery(); 
Rs.close(); 
Ps.close(); 
} 

这里不会用到缓冲. 每次循环向数据库发送一条不同的 SQL 语句. 每次循环都重新 
计算新的访问 方案, 用这种方法我们会浪费大量的 CPU 周期. 但是, 看看下一个片 
段: 

PreparedStatement ps = conn.prepareStatement("select a,b from t where c 
= ?"); 
For(int I = 0; I < 1000; ++I) 
{ 
ps.setInt(1, I); 
ResultSet rs = ps.executeQuery(); 
Rs.close(); 
} 
ps.close(); 

这样就会高效得多. 发送给数据库的语句在 sql 中使用 '?' 符号来参数化. 这意味着 
每次循环 发送的是同一条语句, 在 "c=?" 部分带有不同的参数. 这样就允许数据库 
重用语句的访问方案, 是程序在数据库内部运行得更高效. 这基本上能使你的程序 
运行得更快, 或者使数据库用户能更多 地使用 CPU. 

PreparedStatement 和 J2EE 服务器 

当我们使用 J2EE 服务器的时候, 事情会变得更加复杂. 通常情况下, 一个预先准备 
好的语句 (prepared statement) 是和一个单独的数据库连接相关联的. 当连接关闭时, 
语句就被丢弃 了. 一般来说, 一个胖客户端应用程序在得到一个数据库连接后会一 
直保持到程序结束. 它会使用 两种方法创建所有的语句: 急切创建(eagerly) 或者 懒 
惰创建(lazily). Eagerly是说, 当程序启动时全部创建. Lazily是说随用随创建. 急切 
的方法会在程序启动时有些延时, 但是一旦程序启动以后, 运行很好. 懒惰的方法启 
动很快, 但是当程序运行时, 预先准备的语句在第一次使用是创建. 这就会造成性能 
不平衡, 知道所有的 语句都准备好了, 但是最终程序会和急切方法一样快. 哪一种 
最好要看你需要的是快速启动还是 均衡的性能. 

一个 J2EE 应用程序所带来的问题就是它不能像这样工作. 它只在一个请求的生存 
时间中保持一个 连接. 这意味着在他处理每一个请求时都会重新创建语句, 就不象 
胖客户端只创建一次, 而不是每 个请求都创建那样有效, 

当 J2EE 服务器给你的程序一个连接时, 并不是一个真正的连接, 而是一个经过包装 
的. 你可以 通过查看那个连接的类的名字来检验一下. 它不是一个数据库的 JDBC 
连接, 是你的服务器创建 的一个类. 通常, 如果你调用一个连接的 close 方法, 那么 
jdbc 驱动程序会关闭这个连接. 我们希望的是当 J2EE 应用程序调用 close 的时候, 
连接会返回到连接池中. 我们通过设计一个 代理的 jdbc 连接类来做这些, 但看起来 
就象是实际的连接. 当我们调用这个连接的任何方法时, 代理类就会把请求前递给 
实际的连接. 但是, 当我们调用类似 close 的方法时, 并不调用实际 连接的 close 方 
法, 只是简单地把连接返回给连接池, 然后把代理连接标记为无效, 这样当它 被应 
用程序重新使用时, 我们会得到异常. 

包装是非常有用的, 因为它帮助 J2EE 应用程序服务器实现者比较聪明地加上预先 
准备语句的 支持. 当程序调用 Connection.prepareStatement 时, 由驱动程序返回一 
个 PreparedStatement 对象. 当应用程序得到它时, 保存这个句柄, 并且在请求完成 
时, 关闭 请求之前关闭这个句柄. 但是, 在连接返回到连接池之后, 以后被同样或者 
另一个应用程序重用时, 那么, 我们就理论上希望同样的 PreparedStatement 返回给 
应用程序. 

J2EE PreparedStatement 缓冲 

J2EE PreparedStatement 缓冲由 J2EE 服务器内部的连接池管理器使用一个缓冲区 
来 实现. J2EE 服务器在连接池中保存一个所有数据库的预先准备语句的一个列表. 
当一个程序 调用一个连接的 prepareStatement 方法时, 服务器先检查这个语句是否 
已经有了, 如果 是, 相应的 PreparedStatement 就在缓冲区内, 就返回给应用程序, 如 
果不是, 请求就 会传递给 jdbc 驱动程序, 请求/预先准备语句 对象就会加入到缓冲 
区里. 

对于每一个连接我们需要一个缓冲区, 因为这是 jdbc 驱动程序的工作要求. 任何返 
回的 preparedStatement 都是针对这个连接的. 

如果我们要利用缓冲区的优势, 要使用和前面相同的规则. 我们需要使用参数话的 
查询, 这样 它们就会和已经在缓冲区的某一个匹配. 大多数应用程序服务器都允许 
你调整缓冲区的大小. 

概要 

总之, 对于预先准备语句, 我们应该使用参数化的查询. 这样允许数据库重用已经存 
在的访问 方案, 从而减轻数据库的负担. 这样的缓冲区是这个数据库范围的, 所以 
你可以安排你所有的 应用程序, 使用相似的参数化的 SQL, 就会提高这样的缓冲区 
方案的效率, 因为一个应用程序 可以使用另一个应用程序的语句. 一个应用服务器 
的优势也在于此, 因为访问数据库的逻辑应该 集中在数据访问层上(OR 映射, 实体 
bean 或者直接 JDBC). 

最后, 预先准备语句的正确使用也让你利用应用程序服务器的预先准备语句的缓冲 
区的好处. 会提高你的应用程序的性能, 因为应用程序通过对以前的预先准备语句 
的重用减少 JDBC 驱动程序调用的次数. 这样使它能和胖客户端的效率竞争, 并且 
去掉了不能保持一个长期 连接的坏处. 

如果你使用参数化的预先准备语句, 就可以提高数据库和你的服务器端的代码的效 
率. 这些提高 都会允许你的应用程序提高性能. 