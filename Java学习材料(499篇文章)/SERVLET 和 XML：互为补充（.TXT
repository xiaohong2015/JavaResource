作者：zergman
email: zergman@chinaasp.com
日期：2001-6-15 13:57:18
[TABLE]                                 [TD]                                 [#FFFFFF]                                 [b]Download it now![/b][/#]                                 [/TD]                             [/TR]                             [TR]                                 [TD]                                                          [url href=ftp://www6.software.ibm.com/software/developer/library/servlets-and-xml.pdf][B]PDF[/B][/url]                                  (79.4 KB)
                                 [url href=http://www.adobe.com/prodindex/acrobat/readstep.html]Free Acrobat&#153; Reader[/url]                                 [/TD]                             [/TR]-->[TR][TD][url href=http://www.cn.ibm.com/developerWorks/java/servlets-and-xml/index_eng.shtml][img]http://www.cn.ibm.com/developerWorks/i/src.jpg[/img][/url] [/TD][/TR][/TABLE]
[b]Servlet 和 XML：互为补充[/b]
Doug Tidwell 
developerWorks 职员 
2000 年 4 月
[TABLE][TR][TD][#ffffff][B]内容：[/B][/#][/TD][/TR][TR][TD][img]http://www.cn.ibm.com/developerWorks/i/c.gif[/img][/TD][/TR][TR][TD][img]http://www.cn.ibm.com/developerWorks/i/c.gif[/img][/TD][/TR][TR][TD] [url href=http://www.cn.ibm.com/developerWorks/java/servlets-and-xml/index.shtml#2]我们的第一个 servlet 示例[/url][/TD][/TR][TR][TD] [url href=http://www.cn.ibm.com/developerWorks/java/servlets-and-xml/index.shtml#3]一个基本的 servlet[/url][/TD][/TR][TR][TD] [url href=http://www.cn.ibm.com/developerWorks/java/servlets-and-xml/index.shtml#4]生成 XML 段[/url][/TD][/TR][TR][TD] [url href=http://www.cn.ibm.com/developerWorks/java/servlets-and-xml/index.shtml#5]与数据库对接[/url][/TD][/TR][TR][TD] [url href=http://www.cn.ibm.com/developerWorks/java/servlets-and-xml/index.shtml#6]小结[/url][/TD][/TR][TR][TD] [url href=http://www.cn.ibm.com/developerWorks/java/servlets-and-xml/index.shtml#resources]参考资料[/url][/TD][/TR][TR][TD] [url href=http://www.cn.ibm.com/developerWorks/java/servlets-and-xml/index.shtml#author]作者简介[/url][/TD][/TR][TR][TD][img]http://www.cn.ibm.com/developerWorks/i/c.gif[/img][/TD][/TR][/TABLE]
[BLOCKQUOTE]研究 Java servlet 和 XML 如何共同生成 XML 文档和 DOM 树，以及它们如何与数据库对接。本文包括几项有用的技术：使用 HTTP 参数控制 DOM 树的处理与生成，而无需 XML 源文档。[/BLOCKQUOTE]

对 Java 程序员来说，Servlet 和 XML 是最令人振奋的两项技术。本文是为 2000 年 2 月 17 日旧金山 City Java 用户组准备的演示文稿。在本文中您将看到如何使用 servlet 组成一个简单的 XML 文档，构建一个 DOM 树，并将部分内容显示在用户屏幕上，最后您将看到如何从一个数据库查询生成 XML。
对于本文讨论的示例来说，我们将扩展 HTTPServlet 类。HTTPServlet 类提供了通常与 CGI 程序相关的功能。它支持 put 和 get，并且使您的代码具有对 HTTP 请求标头的完全访问权，包括 UserAgent 域。我们将创建一些简单的 servlet，并说明它们如何处理以 XML 标签标记的信息。在这一过程中我们还将说明文档对象模型 (DOM) 的一些方法。这些简单的应用程序将使您了解当将 servlet 和 XML 组合在一起时您能够做哪些事情。
[b]第一个 servlet 示例[/b] 
作为开始，我们将编写一个用来生成 XML 文档的 10 行 servlet。在构建理解 XML 的 servlet 时，我们将按以下三个步骤进行： [OL][LI]将内容类型设为 text/xml。 [LI]创建 XML 文档。 [LI]将 XML 文档写回客户机。 [/LI][/OL]
在我们的大多数 Servlet 中，主要精力放在第二步。我们可能根据数据库查询创建一个 XML 文档，也可能基于从客户传送来的 HTTP 参数生成它，或者也可能使用其他类型的数据检索或生成方法。在本文的示例中，将主要考虑 HTTP 参数和数据库查询。
[b]一个基本的 servlet[/b] 
对于第一个示例，第二步“创建 XML 文档”[I]不是[/I]我们所关心的；我们只想生成一个有效的 XML 文档。我们已将文档硬编码到源代码中，如清单 1 所示。[TABLE][TR][TD]Color-coding our colorful coding[/b] -->
[B]彩色编码[/B] 
彩色编码清单是本文的一个特色，我们正在 dW 进行试验。为了生成我们的彩色编码清单，我正在使用一些开放源代码的工具。首先，我将文档（Java、HTML、XML 等）载入 Emacs 中。Emacs 定义了关键字、注释、函数名以及其他编程语言构件（大约有十多种）的颜色。在 Emacs 载入文件并为其加上颜色以后，我使用 HTMLize 程序包，这是一种用曾经流行的 Emacs Lisp 语言编写的开放源代码实用工具。HTMLize 接收一个清单（这个清单看起来与在 Emacs 中完全一样），然后将其转换为 HTML。结果将是一个完全彩色编码的文件，它突出显示关键字、注释、函数名等。
请告拆我们您对这些新的、改进的代码清单的想法。
如果您也想这样做，请参阅[url href=http://www.cn.ibm.com/developerWorks/java/servlets-and-xml/index.shtml#resources]参考资料[/url]中的相应链接。[/TD][/TR][/TABLE]
[b]清单 1. xmlfromscratch.java[/b] [TABLE][TR][TD][PRE][#993333]public[/#] [#993333]class[/#] [#006600]xmlfromscratch[/#] [#993333]extends[/#] [#006600]HttpServlet[/#] {  [#993333]public[/#] [#006600]void[/#] [#666633]service[/#]([#006600]HttpServletRequest[/#] [#000066]request[/#],                      [#006600]HttpServletResponse[/#] [#000066]response[/#])    [#993333]throws[/#] [#006600]IOException[/#], [#006600]ServletException[/#]  {    response.setContentType([#0000ff]"text/xml"[/#]);    [#006600]PrintWriter[/#] [#000066]out[/#] = response.getWriter();        out.println([#0000ff]"<?xml version=\"1.0\"?>"[/#]);    out.println([#0000ff]"<greeting language=\"en_US\">"[/#]);    out.println([#0000ff]"  Hello, World!"[/#]);    out.println([#0000ff]"</greeting>"[/#]);  }}[/PRE][/TD][/TR][/TABLE]
这一段令人兴奋的代码生成的结果如下所示：
[b]清单 2. xmlfromscratch.java 的结果[/b] [TABLE][TR][TD][PRE][#993333]<?[/#][#006600]xml version="1.0"[/#][#993333]?>[/#]<greeting>[#0000ff]  Hello, World![/#]</greeting>[/PRE][/TD][/TR][/TABLE]
您可以查看[url href=http://www.cn.ibm.com/developerWorks/java/servlets-and-xml/xmlfromscratch-src.html]完整清单的 HTML 视图[/url]或直接查看 [url href=http://www.cn.ibm.com/developerWorks/java/servlets-and-xml/xmlfromscratch.java]Java 源文件[/url]。
[b]生成 XML 段[/b] 
现在，我们已经创建了一个 servlet，它通过硬编码生成一个没有意义的简单 XML 文档。在下一个 servlet 中，我们从零开始生成一个 DOM 树，然后将 DOM 树的一部分显示在请求者的屏幕上。向请求者发送回的 DOM 树部分取决于 servlet 接收到的 HTTP 参数。本例展示了几项有用的技术：使用 HTTP 参数控制 DOM 树的处理与生成，而无需 XML 源文档。
清单 3 显示了处理 HTTP 参数的代码段：
[b]清单 3. xmlfromdom.java[/b] [TABLE][TR][TD][PRE]  [#993333]public[/#] [#006600]void[/#] [#666633]service[/#]([#006600]HttpServletRequest[/#] [#000066]request[/#],                      [#006600]HttpServletResponse[/#] [#000066]response[/#])    [#993333]throws[/#] [#006600]IOException[/#], [#006600]ServletException[/#]  {    response.setContentType([#0000ff]"text/xml"[/#]);    [#006600]PrintWriter[/#] [#000066]out[/#] = response.getWriter();        [#006600]Enumeration[/#] [#000066]keys[/#];    [#006600]String[/#] [#000066]key[/#];    [#006600]String[/#] [#000066]requestedSubtree[/#] = [#0000ff]""[/#];    keys = request.getParameterNames();    [#993333]while[/#] (keys.hasMoreElements())    {      key = ([#006600]String[/#]) keys.nextElement();      [#993333]if[/#] (key.equalsIgnoreCase([#0000ff]"subtree"[/#]))        requestedSubtree = request.getParameter(key);    }[/PRE][/TD][/TR][/TABLE]
正如在上一个示例中那样，我们将内容类型设置为 text/xml。在此之后，我们使用 HttpServletRequest.getParameterNames 方法从 HTTP 请求中检索所有参数。
在处理完这些参数以后，我们需要查找用户所请求的信息。我们使用的信息从对象中构建 DOM 树；该 DOM 树包含了莎士比亚十四行诗的文本，以及关于这首十四行诗的其他信息。我们将根据 HTTP subtree 参数返回 DOM 树的一部分。清单 4 显示了构建 DOM 树的部分代码：
[b]清单 4. 构建 DOM 树[/b] [TABLE][TR][TD][PRE]  [#006600]Document[/#] [#000066]doc[/#] = [#990099]null[/#];  [#006600]Element[/#] [#000066]author[/#] = [#990099]null[/#];  [#006600]Element[/#] [#000066]lines[/#] = [#990099]null[/#];  [#006600]Element[/#] [#000066]title[/#] = [#990099]null[/#];   [#993333]public[/#] [#006600]void[/#] [#666633]initialize[/#]()  {      doc = ([#006600]Document[/#])Class.        forName([#0000ff]"org.apache.xerces.dom.DocumentImpl"[/#]).        newInstance();    [#993333]if[/#] (doc != [#990099]null[/#])      {        [#006600]Element[/#] [#000066]root[/#] = doc.createElement([#0000ff]"sonnet"[/#]);        root.setAttribute([#0000ff]"type"[/#], [#0000ff]"Shakespearean"[/#]);          author = doc.createElement([#0000ff]"author"[/#]);          [#006600]Element[/#] [#000066]lastName[/#] = doc.createElement([#0000ff]"last-name"[/#]);        lastName.appendChild(doc.createTextNode([#0000ff]"Shakespeare"[/#]));        author.appendChild(lastName);[/PRE][/TD][/TR][/TABLE]
我们创建了一个 Java 类的实例，该类实现了 DOM Document 接口，然后我们要求那个节点为我们创建各种节点。您很容易重新编写这个应用程序，使它通过分析 XML 文件生成 DOM 树。为了简化这个示例（并减少我的工作量），我们定义了一些实例变量来保存准备为其提供服务的节点的值。这些值在类声明顶部声明，并在 initialize 方法中初始化。
最后一步是将被请求的 DOM 树部分发送给用户。为了实现这一任务，我们使用一个递归方法，printDOMTree，它处理节点及其所有子节点。因为这个方法是递归的，所以我们从文档根节点还是从 DOM 树的其他节点开始并不重要。如果所请求的是我们知道的一个节点，则可以将这个节点传递给方法 printDOMTree。否则，我们可以传递 Document 节点。清单 5 显示了这一步骤。
 