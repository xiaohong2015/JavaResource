作者：运气
email: webmaster@chinaspx.com
日期：7/4/2001 1:40:53 PM
　　摘要：

　　通过使用JDK 1.3中引入的RMI和Proxy API，本篇文章讨论了一种允许一台或多台servlet服务器在一台或多台对话服务器上维护对话信息的技术，采用这种技术后，单一点故障就不会再出现了。 

　　如果系统中有一台或多台servlet服务器，对话信息只存在于运行着JVM的一台servlet服务器上，而不会被传输给其他servlet服务器。如果该servlet服务器当机或因为维护而被关机，任何保存在对话中的信息都会丢失。如果一个系统中有多台servlet服务器，一个带有对话的用户需要访问对话中的任何信息，都需要被重新定向到同一台servlet服务器。曾经有专家建议采用关系数据库保存所有的对话信息，但这仍然存在单一点故障的危险，那就是运行关系数据库的服务器。而且如果数据库出了故障，所有的servlet服务器就都不能再访问对话信息了。另外，在数据库中保存可串行化的对象在有些数据库中是比较难以实现的。

　　多服务器对话管理的另一个可能的途径是利用JavaSpaces API来维护对话对象中的记录。当然，如果运行JavaSpaces的服务器由于维护或故障而被关机，也会丢失所有的对话信息，我们再一次遇到了单一点故障的问题。

　　要实现带有N个节点的分布式对话服务器，我们必须解决如下的三个问题：

　　━━如何建立一个库来存贮对话信息。

　　━━如何对分布式对话信息存贮库进行同步。 

　　━━在一个对话信息存贮库脱离网络后，如何使该服务器从下一个对话信息存贮库中访问对话信息。


　　Mnemosyne的简介

　　我们用来存贮对话信息的库是Mnemosyne界面的执行。执行Mnemosyne的对象负责管理对话信息存贮库中的所有对象，任何试图写、访问或删除库中对象的对象都必须调用Mnemosyne的相应的方法来实现相应的操作。

　　一个对象要存贮在Mnemosyne，就必须执行Memory界面，该界面定义了equalsMemory()操作来探测二个内存对象是否相同，这就使 Mnemosyne判断出应当把哪个对象返回给read要求或take要求。Memory界面也可以进行串行化扩充，以便我们可以用RMI在网络上传输该对象。